/*
 * ICA Rest API
 *
 * This API can be used to interact with Illumina Connected Analytics.<br> <p> Authentication to the  API can be done in multiple ways:<br> <ul><li>For the entire API, except for the POST /tokens endpoint: API-key + JWT</li> <li>Only for the POST /tokens endpoint: API-key + Basic Authentication</li></ul> </p> <p> <b>API-key</b><br> API keys are managed within the Illumina portal where you can manage your profile after you have logged on. The API-key has to be provided in the X-API-Key header parameter when executing API calls to ICA. In the background, a JWT will be requested at the IDP of Illumina to create a session. A good practice is to not use the API-key for every API call, but to first generate a JWT and to use that for authentication in subsequent calls.<br> </p> <p> <b>JWT</b><br> To avoid using an API-key for each call, we recommend to request a JWT via the POST /tokens endpoint  using this API-key. The JWT will expire after a pre-configured period specified by a tenant administrator through the IAM console in the Illumina portal. The JWT is the preferred way for authentication.<br>A not yet expired, still valid JWT could be refreshed using the POST /tokens:refresh endpoint.<br> </p> <p> <b>Basic Authentication</b><br> Basic authentication is only supported by the POST /tokens endpoint for generating a JWT. Use \"Basic base64encoded(emailaddress:password)\" in the \"Authorization\" header parameter for this authentication method. In case having access to multiple tenants using the same email-address, also provide the \"tenant\" request parameter to indicate what tenant you would like to request a JWT for. </p>
 *
 * The version of the OpenAPI document: 3
 *
 * Generated by: https://openapi-generator.tech
 */

use reqwest;

use super::{configuration, Error};
use crate::apis::ResponseContent;

/// struct for typed errors of method [`get_bundle_data`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBundleDataError {
    DefaultResponse(crate::models::Problem),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`link_data_to_bundle`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LinkDataToBundleError {
    DefaultResponse(crate::models::Problem),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`unlink_data_from_bundle`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnlinkDataFromBundleError {
    DefaultResponse(crate::models::Problem),
    UnknownValue(serde_json::Value),
}

pub async fn get_bundle_data(
    configuration: &configuration::Configuration,
    bundle_id: &str,
    full_text: Option<&str>,
    id: Option<&str>,
    filename: Option<&str>,
    filename_match_mode: Option<&str>,
    file_path: Option<&str>,
    file_path_match_mode: Option<&str>,
    status: Option<&str>,
    format_id: Option<&str>,
    format_code: Option<&str>,
    r#type: Option<&str>,
    parent_folder_id: Option<&str>,
    parent_folder_path: Option<&str>,
    creation_date_after: Option<&str>,
    creation_date_before: Option<&str>,
    status_date_after: Option<&str>,
    status_date_before: Option<&str>,
    user_tag: Option<&str>,
    user_tag_match_mode: Option<&str>,
    run_input_tag: Option<&str>,
    run_input_tag_match_mode: Option<&str>,
    run_output_tag: Option<&str>,
    run_output_tag_match_mode: Option<&str>,
    connector_tag: Option<&str>,
    connector_tag_match_mode: Option<&str>,
    technical_tag: Option<&str>,
    technical_tag_match_mode: Option<&str>,
    not_in_run: Option<&str>,
    not_linked_to_sample: Option<&str>,
    instrument_run_id: Option<Vec<String>>,
    page_offset: Option<&str>,
    page_token: Option<&str>,
    page_size: Option<&str>,
    sort: Option<&str>,
) -> Result<crate::models::BundleDataPagedList, Error<GetBundleDataError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/bundles/{bundleId}/data",
        local_var_configuration.base_path,
        bundleId = crate::apis::urlencode(bundle_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = full_text {
        local_var_req_builder =
            local_var_req_builder.query(&[("fullText", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = id {
        local_var_req_builder = local_var_req_builder.query(&[("id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = filename {
        local_var_req_builder =
            local_var_req_builder.query(&[("filename", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = filename_match_mode {
        local_var_req_builder =
            local_var_req_builder.query(&[("filenameMatchMode", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = file_path {
        local_var_req_builder =
            local_var_req_builder.query(&[("filePath", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = file_path_match_mode {
        local_var_req_builder =
            local_var_req_builder.query(&[("filePathMatchMode", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = status {
        local_var_req_builder =
            local_var_req_builder.query(&[("status", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = format_id {
        local_var_req_builder =
            local_var_req_builder.query(&[("formatId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = format_code {
        local_var_req_builder =
            local_var_req_builder.query(&[("formatCode", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = r#type {
        local_var_req_builder =
            local_var_req_builder.query(&[("type", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = parent_folder_id {
        local_var_req_builder =
            local_var_req_builder.query(&[("parentFolderId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = parent_folder_path {
        local_var_req_builder =
            local_var_req_builder.query(&[("parentFolderPath", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = creation_date_after {
        local_var_req_builder =
            local_var_req_builder.query(&[("creationDateAfter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = creation_date_before {
        local_var_req_builder =
            local_var_req_builder.query(&[("creationDateBefore", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = status_date_after {
        local_var_req_builder =
            local_var_req_builder.query(&[("statusDateAfter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = status_date_before {
        local_var_req_builder =
            local_var_req_builder.query(&[("statusDateBefore", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_tag {
        local_var_req_builder =
            local_var_req_builder.query(&[("userTag", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_tag_match_mode {
        local_var_req_builder =
            local_var_req_builder.query(&[("userTagMatchMode", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = run_input_tag {
        local_var_req_builder =
            local_var_req_builder.query(&[("runInputTag", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = run_input_tag_match_mode {
        local_var_req_builder =
            local_var_req_builder.query(&[("runInputTagMatchMode", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = run_output_tag {
        local_var_req_builder =
            local_var_req_builder.query(&[("runOutputTag", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = run_output_tag_match_mode {
        local_var_req_builder =
            local_var_req_builder.query(&[("runOutputTagMatchMode", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = connector_tag {
        local_var_req_builder =
            local_var_req_builder.query(&[("connectorTag", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = connector_tag_match_mode {
        local_var_req_builder =
            local_var_req_builder.query(&[("connectorTagMatchMode", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = technical_tag {
        local_var_req_builder =
            local_var_req_builder.query(&[("technicalTag", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = technical_tag_match_mode {
        local_var_req_builder =
            local_var_req_builder.query(&[("technicalTagMatchMode", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = not_in_run {
        local_var_req_builder =
            local_var_req_builder.query(&[("notInRun", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = not_linked_to_sample {
        local_var_req_builder =
            local_var_req_builder.query(&[("notLinkedToSample", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = instrument_run_id {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(
                &local_var_str
                    .into_iter()
                    .map(|p| ("instrumentRunId".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => local_var_req_builder.query(&[(
                "instrumentRunId",
                &local_var_str
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref local_var_str) = page_offset {
        local_var_req_builder =
            local_var_req_builder.query(&[("pageOffset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_token {
        local_var_req_builder =
            local_var_req_builder.query(&[("pageToken", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_size {
        local_var_req_builder =
            local_var_req_builder.query(&[("pageSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort {
        local_var_req_builder =
            local_var_req_builder.query(&[("sort", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-API-Key", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetBundleDataError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn link_data_to_bundle(
    configuration: &configuration::Configuration,
    bundle_id: &str,
    data_id: &str,
) -> Result<(), Error<LinkDataToBundleError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/bundles/{bundleId}/data/{dataId}",
        local_var_configuration.base_path,
        bundleId = crate::apis::urlencode(bundle_id),
        dataId = crate::apis::urlencode(data_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-API-Key", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<LinkDataToBundleError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn unlink_data_from_bundle(
    configuration: &configuration::Configuration,
    bundle_id: &str,
    data_id: &str,
) -> Result<(), Error<UnlinkDataFromBundleError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/bundles/{bundleId}/data/{dataId}",
        local_var_configuration.base_path,
        bundleId = crate::apis::urlencode(bundle_id),
        dataId = crate::apis::urlencode(data_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-API-Key", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<UnlinkDataFromBundleError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
